### Splyt - 96 points (105 solves)

> Bob splitted a secret and gave some pieces of it to some of his friends. We managed to convince Eve and Chris to give us their shares.

For this crypto challenge we are given a zip file containing a couple of files, more importantly: splyt.py, build.sh, challenge.json and init.py.

The splyt.py script splits a text file by multiple shares to be distributed for N parties. To reconstruct the original message, we need to at least T people (given by the threshold variable in the script) to join their secrets. The thing is, the challenge.json file only gives us 3 shares and we need 13 to derive the message. (The build.sh script provides this information)

Each share consists of 31 integers, corresponding to the letters of the original message. The secret share scheme used here is called Shamir's Secret Sharing Scheme as described in the init file:

```python
import os


class Splyt:
    @staticmethod
    def split(secret, participants, threshold):
        """
        Split a secret ASCII string into N shares using Shamir Secret Sharing Scheme so that (at least) T shares
        are necessary to reconstruct the secret.
        :param secret: ASCII string to split
        :param participants: the number N of participants (number of shares returned)
        :param threshold: the number T of participants required to reconstruct the secret
        :return: shares: list of dictionaries [{"x":int, "y":[int]}]
        """
        coefficients = Splyt.pick_coefficients(threshold)
        shares = []
        for i in range(participants):
            x = i + 1
            share = {"x": x, "y": []}
            for s in secret:
                y = Splyt.compute_poly(x, ord(s), coefficients)
                share["y"].append(y)
            shares.append(share)

        return shares

    @staticmethod
    def join(shares):
        """
        Rejoin a list of secrets generated by split(), using Lagrange
        :param shares: a list of dictionaries returned by split()
        :return: the original string
        """
        secret = ""
        secret_len = len(shares[0]["y"])
        for i in range(secret_len):
            points = [{"x": share["x"], "y": share["y"][i]} for share in shares]
            secret += chr(Splyt.compute_lagrange_interpolating_polynomial(0, points))
        return secret

    @staticmethod
    def pick_coefficients(threshold):
        return [b for b in os.urandom(threshold - 1)]

    @staticmethod
    def compute_poly(x, secret, coefficients):
        y = secret
        for i, coefficient in enumerate(coefficients):
            y = (y + coefficient * int(x ** (i+1))) % 255
        return y

    @staticmethod
    def compute_lagrange_interpolating_polynomial(x, points):
        s = 0
        for i, point in enumerate(points):
            s = (s + point["y"] * Splyt.lagrange_basis_polynomial(x, points, i)) % 255
        return s

    @staticmethod
    def lagrange_basis_polynomial(x, points, i):
        numerator = 1
        denominator = 1
        for j, p in enumerate(points):
            if i == j:
                continue
            numerator *= (x - p["x"])
            denominator *= (points[i]["x"] - p["x"])
        return int(numerator/denominator)

```

Looking carefully at the file above, we can see that the polynomial used to generate the secrets is always the same in the compute_poly function. With this information, we can check the shares and deduce the flag only by looking at the integers. The first share has the following values:

```
[26,32,21,27,47,38,230,41,39,228,34,27,19,38,231,34,24,227,33,19,228,39,19,34,227,40,19,26,41,34,49,189]
```

Since we know the format of the flag (flag{...}) we can start by replacing the integers corresponding to those characters. For example, 26 corresponds to the letter 'f' and 32 corresponds to the letter 'l':

```
flag{??????????????????????????}
```

I noticed that we could just open the ascii table and replace other characters because the difference between the integers of the share are the same as the differences of the decimal values in the table. For example, 32 - 26 = 6 and in the ascii table, the letter 'f' and 'l' are separated by 6 characters. With this we get:

```
flag{r?us?ng_r?nd?m_?s_n?t_fun}
```

Now, the remaining integers were bigger than 127 and those don't fit in the table but we could look into the second share because it features higher integers. Applying the differences we found out they were numbers and the flag is:

```
flag{r3us1ng_r4nd0m_1s_n0t_fun}
```